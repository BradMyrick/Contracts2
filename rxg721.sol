// SPDX-License-Identifier: MIT

pragma solidity ^0.8.7;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol";
import "@openzeppelin/contracts/utils/Context.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

/**
 * @dev {ERC721} token, including:
 *
 *  - ability for holders to burn (destroy) their tokens
 *  - a minter role that allows for token minting (creation)
 *  - a pauser role that allows to stop all token transfers
 *  - token ID and URI autogeneration
 *  - ability for creator to set minting price in base units
 *  - 1% fee for each token minted delivered to the manager
 *  - ability for creator to set the token name and symbol  
 *  
 */
contract ERC721ManagedLaunch is
    Context,
    ERC721Enumerable,
    ERC721Burnable
{
// Variables
    using Counters for Counters.Counter;
    address public manager;
    address public creator;
    bool public launched;
    uint256 public mintPrice;// set by user
    uint256 public fee; // 1% of the mint price
    uint256 public totalFee;
    uint256 public totalEarned;
    uint public maxSupply;
    Counters.Counter private _tokenIdTracker;
    string private _baseTokenURI;
// Modifiers
    modifier onlyManager {
        require(msg.sender == manager);
        _;
    }
    modifier onlyCreator {
        require(msg.sender == creator);
        _;
    }
    modifier onlyCreatorOrManager {
        require(msg.sender == creator || msg.sender == manager);
        _;
    }
// Events
    event CreatorTokenWithdrawal(address indexed _from, uint256 _amount);
// Constructor
    /**
     * @dev deploys the contract.
     *
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * See {ERC721-tokenURI}.
     */
    constructor(
        string memory name,
        string memory symbol,
        string memory baseTokenURI, // should be placeholder
        address _manager,
        uint256 _mintPrice,
        uint _maxSupply
    ) ERC721(name, symbol) {
        require(_maxSupply > 0 && _maxSupply <= 10000, "max supply must be between 1 and 10000");
        require(_mintPrice > 0, "mint price must be greater than 0");
        require(_manager != address(0), "manager cannot be the zero address");
        _baseTokenURI = baseTokenURI;
        manager = _manager;
        creator = msg.sender;
        mintPrice = _mintPrice;
        launched = false;
        maxSupply = _maxSupply;
        fee = mintPrice * 1 / 10000; // 1% of the mint price
    }
// Functions
    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }

    /**
     * @dev Creates a new token for `to`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_mint}.
     *
     * Requirements:
     *
     * - the caller must have the `MINTER_ROLE`.
     */
    function mint() public payable virtual {
        require(_tokenIdTracker.current() < maxSupply, "cannot mint more than the max supply");
        // require the minter pay the mint cost
        _tokenIdTracker.increment();
        require(msg.value == mintPrice, "Minting price mismatch");
        _mint(msg.sender, _tokenIdTracker.current());
        totalFee += fee;
        totalEarned += mintPrice - fee;
    }


    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual override(ERC721, ERC721Enumerable) {
        super._beforeTokenTransfer(from, to, tokenId);
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override( ERC721, ERC721Enumerable)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }

    /**
     * @dev allow the creator to remove the paid minting revenue from the contract
     *
     */
    function cashOut() external onlyCreatorOrManager {
        require(totalEarned > 0, "No tokens to cash out");
        require(totalFee > 0, "No fee processed to remove");
        // send the creator the total earned minus the fee
        payable(creator).transfer(totalEarned);
        totalEarned = 0;
        // send the fee to the manager
        payable(manager).transfer(totalFee);
        totalFee = 0;
        emit CreatorTokenWithdrawal(msg.sender, totalEarned);
    }

    /**
     * @dev one time use manager or creator function to change the base URI
     * for launch reveals
     */
    function setBaseTokenURI(string memory _BaseURI) external onlyCreatorOrManager {
        require(launched == false, "cannot change base token URI after launch");
        _baseTokenURI = _BaseURI;
        launched = true; // launch the contract
    }
}